synchronized 的使用方式： 1.给对象加锁 2.给方法加锁 3.给代码块加锁 4.给类加锁

## 锁对象

锁实际上是加在对象上的，那么被加了锁的对象我们称之为锁对象，在 java 中，任何一个对象都能成为锁对象。
为了更好着理解虚拟机是如何知道这个对象就是一个锁对象的，下面简单介绍一下 java 中一个对象的结构。
java 对象在内存中的存储结构主要有一下三个部分： 1.对象头（Markword（4 字节），Class 对象指针（4 字节）） 2.实例数据 3.对齐填充数据（按 8 字节对齐）
这里强调一下，对象头里的数据主要是一些运行时的数据。
其简单的结构如下

| 长度     | 内容          | 说明                         |
| -------- | ------------- | ---------------------------- |
| 32/64bit | Mark Word     | hashCode GC 分代年龄，锁信息 |
| 32/64bit | Class pointer | 指向对象类型数据的指针       |
| 32/64bit | Array Length  | 数组的长度（当对象为数组时） |

从表格可以看到，对象中关于锁对信息锁存在 Markword 里的。

当我们创建一个对象 LockObject 时，该对象的部分 Markword 关键数据如下：

| bit fields | 是否偏向锁 | 锁标志位 |
| ---------- | ---------- | -------- |
| hash       | 0          | 01       |

偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻，就有了偏向锁的标志位，这也说明了所有对象都是可偏向的，但所有对象的状态都为“0”，也同时说明所有被创建的对象的偏向锁并没有生效

# 偏向锁

当线程执行到临界区（critical section）时，此时会利用 CAS(Compare and Swap)操作，将线程 ID 插入到 Markword 中，同时修改偏向锁的标志位。

> 临界区：就是只允许一个线程进去执行操作的区域，即同步代码块，只要对多线程并发有影响的都叫临界区。CAS 是一个原子性操作.

此时 Mark word 的结构信息如下：
|bit fields|是否偏向锁| 锁标志位|
|----|----|----|
|hash| 0| 01|

偏向锁的状态为“1”，说明对象的偏向锁生效了，同时也可以看到那个线程获取了该对象的锁。

> 偏向锁：jdk1.6 引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说，这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。

也就是说:
在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行加锁或者解锁操作，而是会做以下的步骤：

1. Load-and-test，也就是简单判断一下当前线程 id 是否与 Markword 当中的线程 id 是否一致。
2. 如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码。
3. 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。
4. 如果还未偏向，则利用 CAS 操作来竞争锁，也即是第一次获取锁时的操作。
   如果此对象已经偏向了，并且不是偏向自己，则说明存在了竞争。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成轻量级锁了。

> 偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。

## 锁膨胀

**_当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的锁膨胀。_**

## 锁撤销

由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：

1. 在一个安全点停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复记录和 Markword，使其变成无锁状态。
3. 唤醒当前线程，将当前锁升级成轻量级锁。
   所以如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们一开始就把偏向锁默认关闭。

# 轻量级锁

锁撤销升级为轻量级锁之后，那么对象的 Markword 也会进行相应的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程：

1. 线程在自己的栈桢中创建锁记录 LockRecord。
2. 将锁对象的对象头中的 MarkWord 复制到线程的刚刚创建的锁记录中‘
3. 将锁记录中的 Owner 指针指向锁对象。
4. 将锁对象的对象头的 Markword 替换为指向偏向锁记录的指针。

## 自旋锁

所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。

> 注意，锁在原地循环的时候，是会消耗 cpu 的，就相当于在执行一个啥也没有的 for 循环。
> 所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。
> 经验表明，大部分同步代码块执行的时间都是很短很短的，也正是基于这个原因，才有了轻量级锁这么个东西。

**_基于这个问题，我们必须给线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。_**
默认情况下，自旋的次数为 10 次，用户可以通过-XX:PreBlockSpin 来进行更改。

## 自适应自旋锁

所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。
假如一个线程 1 刚刚成功获得一个锁，当它把锁释放了之后，线程 2 获得该锁，并且线程 2 在运行的过程中，此时线程 1 又想来获得该锁了，但线程 2 还没有释放该锁，所以线程 1 只能自旋等待，但是虚拟机认为，**_由于线程 1 刚刚获得过该锁，那么虚拟机觉得线程 1 这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程 1 自旋的次数。_**
另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。

> 轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。

# 重量级锁

轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的 monitor 锁来实现的，而 monitor 又依赖操作系统的 MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。

当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的 Markword 部分数据大体如下：
|bit fields| 锁标志位|
|----|----|
|指向 Mutex 的指针| 10|

### 为什么重量级锁开销大呢

主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗 cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。
这就是说为什么重量级线程开销很大的

> 互斥锁(重量级锁)也称为阻塞同步、悲观锁

# 总结
通过上面的分析，我们知道了为什么synchronized关键字为何又深得人心，也知道了锁的演变过程。
也就是说，synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。
这个过程也告诉我们，假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话，那么我们一开始就应该使用重量级锁了，从而省掉一些锁转换的开销。


> 原文链接：https://blog.csdn.net/wdxld/article/details/114218742
